#Ho:varianzas iguales
#Ha:varianzas no son iguales
bartlett.test(vasos$SD~vasos$Family)
bartlett.test(log10(vasos$SD)~vasos$Family)
#Se prueba supuesto de homocedasticidad
#Ho:varianzas iguales
#Ha:varianzas no son iguales
bartlett.test(log10(vasos$SD)~vasos$Family)
#Con interacción
#H0: No hay diferencias entre familias en el tamaño de los vasos controlando por el tamaño del tallo
#HA: Hay diferencias en al menos una familia en el tamaño de los vasos controlando por el tamaño del tallo
ancova.DT<-lm(log10(vasos$VD)~log10(vasos$SD)*vasos$Family)
ancova.DT
suumary(ancova.DT)
summary(ancova.DT)
anova(ancova.DT)
anova(ancova.DT2)
summary(ancova.DT2)
##################################
########### TAREA 4 ##############
##################################
#Definiendo el directorio de trabajo
setwd("///Users/veronicarincon/")
#Librerías a utilizar
library(gplots)
library(multcompView)
library(lsmeans)
library(plotrix)
library(car)
#######Pregunta 1: Vasos de las plantas########
#Cargando los datos
vasos<-read.csv("DatosVasos.csv", header=T)
str(vasos)
summary(vasos)
#Media y desviación segun las familias
FamiliaMedia<-aggregate(vasos$VD, by=list(vasos$Family), mean)
FamiliaMedia
FamiliaSD<-aggregate(vasos$VD, by=list(vasos$Family), sd)
FamiliaSD
#Gráfica de los datos "crudos"
#Grafica de crecimiento por variedades
plotmeans(VD~Family, data=vasos, ylab="Diametro de los vasos (micras)", xlab="Familia", main="Grafica de medias")
boxplot(VD~Family, data=vasos, ylab="Diametro de los vasos (micras)", xlab="Familia", main="Tamano de vasos por familia", col=c("lightcoral","lightblue3","yellowgreen"))
#Revisando el supuesto de igualdad de varianza (homocedasticidad)
#HO: La varianza de las muestras es igual
#HA: La varianza de almenos una muestra es diferente
bartlett.test(VD~Family, data=vasos)
#Nuestras varianzas NO son iguales
#Transformando datos de la varianza para que sean iguales
bartlett.test(log10(VD)~Family, data=vasos)
#Sí hay homocedasticidad, usaremos log10
#Haciendo el anova con log10
#HO: No existen diferencias entre familias en el tamaño de los vasos
#HA: Existen diferencias al menos en una familia en el tamaño de los vasos
anova.logvasos<-aov(log(VD)~Family, data=vasos)
#Revisando el supuesto de normalidad de los residuales
#HO: Los residuales se distribuyen de manera normal;
#HA: Los residuales no se ditribuyen de manera normal
hist(residuals(anova.logvasos))
shapiro.test(residuals(anova.logvasos))
#Los residuales SÍ se distribuyen normalmente
#Corriendo el ANOVA
summary(anova.logvasos)
#Prueba post hoc para calcular cuál o cuáles son las familias diferentes
TukeyHSD(anova.logvasos)
lsm<-lsmeans(anova.logvasos, "Family", adjust="tukey")
cld(lsm, alpha=.05, Letters=letters)
multcompBoxplot(VD~Family, vasos, horizontal = TRUE, compFn = "TukeyHSD", sortFn = "mean", decreasing = TRUE, plotList = list(boxplot = list(fig =c(0, 0.75, 0, 1)), multcompTs = list(fig = c(0.7, 0.85, 0, 1)), multcompLetters = list(fig = c(0.87, 0.97, 0.03, 0.98), fontsize = 20, fontface = "bold")))
##ANCOVA (controlando por el tamaño del tallo)
#Revisando relacion entre variables continuas
aggregate(vasos$SD, by=list(vasos$Family), mean)
aggregate(vasos$SD, by=list(vasos$Family), sd)
#Graficando
boxplot(SD~Family, data=vasos, ylab="Diametro del tallo (cm)", xlab="Familia", main="Tamano de vasos por familia", col=c("lightcoral","lightblue3","yellowgreen"))
plot(VD~SD, data=vasos, xlab="Diametro del tallo (cm)", ylab="Diametro de los vasos (micras)", main="Diametro de las vasos segun el diametro del tallo")
#Los datos NO se relacionan de forma lineal
#HO: No existen relación entre el tamaño de planta y el tamaño de los vasos
#HA: Existen una relación entre el tamaño de planta y el tamaño de los vasos
DT<-lm(VD~SD, data=vasos)
plot(DT)
#Ha:varianzas no son iguales
bartlett.test(vasos$SD~vasos$Family)
#No hay homocedasticidad
#Se rechaza Ho (P.value=2.2e-16). Las varianzas no son iguales.
#Independencia de los residuales
#HO: Los residuales no están correlacionados con el valor ajustado
#HA: Los residuales están correlacionados con el valor ajustado
plot(DT$residuals~DT$fitted.values)
cor.test(abs(DT$residuals), DT$fitted.values)
#Los residuales SÍ están correlacionados con el valor ajustado
#Revisando el supuesto de normalidad de los residuales
#HO: Los residuales se distribuyen de manera normal;
#HA: Los residuales no se ditribuyen de manera normal
hist(DT$residuals)
shapiro.test(DT$residuals)
#Los residuales NO siguen una distribución normal
###Es necesario transformar los datos
plot(log10(VD)~log10(SD), data=vasos, xlab="Diametro del tallo (cm)", ylab="Diametro de los vasos (micras)", main="Diametro de las vasos segun el diametro del tallo")
#Los datos se relacionan de forma lineal
logDT<-lm(log10(VD)~log10(SD), data=vasos)
plot(logDT)
#Ha:varianzas no son iguales
bartlett.test(log10(vasos$SD)~vasos$Family)
#No se rechaza Ho (P-value=0.12).
#Independencia de los residuales
#HO: Los residuales no están correlacionados con el valor ajustado
#HA: Los residuales están correlacionados con el valor ajustado
plot(logDT$residuals~logDT$fitted.values)
cor.test(abs(logDT$residuals), log(DT$fitted.values))
#Los residuales NO están correlacionados con el valor ajustado
#Revisando el supuesto de normalidad de los residuales
#HO: Los residuales se distribuyen de manera normal;
#HA: Los residuales no se ditribuyen de manera normal
hist(logDT$residuals)
shapiro.test(logDT$residuals)
#Los residuales SÍ siguen una distribución normal
summary(logDT)
####Realizando los ancovas
#Con interacción
#H0: No hay diferencias entre familias en el tamaño de los vasos controlando por el tamaño del tallo
#HA: Hay diferencias en al menos una familia en el tamaño de los vasos controlando por el tamaño del tallo
ancova.DT<-lm(log10(vasos$VD)~log10(vasos$SD)*vasos$Family)
plot(ancova.DT)
ancova.DT2<-lm(log10(vasos$VD)~log10(vasos$SD)+vasos$Family)
plot(ancova.DT2)
anova(ancova.DT, ancova.DT2)
#No es necesario tomar en cuenta la interacción, nos quedamos con el modelo más simple
summary(ancova.DT2)
#Prueba post hoc para calcular cuál o cuáles son las familias diferentes
TukeyHSD(anova.logvasos)
##################################
########### TAREA 4 ##############
##################################
#Definiendo el directorio de trabajo
setwd("///Users/veronicarincon/")
#Librerías a utilizar
library(gplots)
library(multcompView)
library(lsmeans)
library(plotrix)
library(car)
#######Pregunta 1: Vasos de las plantas########
#Cargando los datos
vasos<-read.csv("DatosVasos.csv", header=T)
str(vasos)
summary(vasos)
#Media y desviación segun las familias
FamiliaMedia<-aggregate(vasos$VD, by=list(vasos$Family), mean)
FamiliaMedia
FamiliaSD<-aggregate(vasos$VD, by=list(vasos$Family), sd)
FamiliaSD
#Gráfica de los datos "crudos"
#Grafica de crecimiento por variedades
plotmeans(VD~Family, data=vasos, ylab="Diametro de los vasos (micras)", xlab="Familia", main="Grafica de medias")
boxplot(VD~Family, data=vasos, ylab="Diametro de los vasos (micras)", xlab="Familia", main="Tamano de vasos por familia", col=c("lightcoral","lightblue3","yellowgreen"))
#Revisando el supuesto de igualdad de varianza (homocedasticidad)
#HO: La varianza de las muestras es igual
#HA: La varianza de almenos una muestra es diferente
bartlett.test(VD~Family, data=vasos)
#Nuestras varianzas NO son iguales
#Transformando datos de la varianza para que sean iguales
bartlett.test(log10(VD)~Family, data=vasos)
#Sí hay homocedasticidad, usaremos log10
#Haciendo el anova con log10
#HO: No existen diferencias entre familias en el tamaño de los vasos
#HA: Existen diferencias al menos en una familia en el tamaño de los vasos
anova.logvasos<-aov(log(VD)~Family, data=vasos)
#Revisando el supuesto de normalidad de los residuales
#HO: Los residuales se distribuyen de manera normal;
#HA: Los residuales no se ditribuyen de manera normal
hist(residuals(anova.logvasos))
shapiro.test(residuals(anova.logvasos))
#Los residuales SÍ se distribuyen normalmente
#Corriendo el ANOVA
summary(anova.logvasos)
#Prueba post hoc para calcular cuál o cuáles son las familias diferentes
TukeyHSD(anova.logvasos)
#Revisando el supuesto de igualdad de varianza (homocedasticidad)
#HO: La varianza de las muestras es igual
#HA: La varianza de almenos una muestra es diferente
bartlett.test(VD~Family, data=vasos)
#Transformando datos de la varianza para que sean iguales
bartlett.test(log10(VD)~Family, data=vasos)
#Haciendo el anova con log10
#HO: No existen diferencias entre familias en el tamaño de los vasos
#HA: Existen diferencias al menos en una familia en el tamaño de los vasos
anova.logvasos<-aov(log(VD)~Family, data=vasos)
#Corriendo el ANOVA
summary(anova.logvasos)
#Corriendo el ANOVA
summary(anova.logvasos)
shapiro.test(residuals(anova.logvasos))
#Prueba post hoc para calcular cuál o cuáles son las familias diferentes
TukeyHSD(anova.logvasos)
#Transformando datos de la varianza para que sean iguales
bartlett.test(log10(VD)~Family, data=vasos)
summary(ancova.DT2)
#Se prueba supuesto de homocedasticidad
#Ho:varianzas iguales
#Ha:varianzas no son iguales
bartlett.test(log10(vasos$SD)~vasos$Family)
#Se prueba supuesto de homocedasticidad
#Ho:varianzas iguales
#Ha:varianzas no son iguales
bartlett.test(vasos$SD~vasos$Family)
summary(logDT)
#Corriendo el ANOVA
summary(anova.logvasos)
#######Pregunta 2: Diversidad de aves########
#Cargando los datos
clima<-read.csv("Climate.csv", header=T)
str(clima)
summary(clima)
#Revisando gráficas de los datos
plot(clima)
scatterplotMatrix(clima)
#PCA con media = 0 y desviacion estandar = 1
PCAclima<- prcomp(clima[2:8], center = T, scale. = T)
summary(PCAclima)
#######Pregunta 2: Diversidad de aves########
#Cargando los datos
clima<-read.csv("Climate.csv", header=T)
str(clima)
summary(clima)
#Revisando gráficas de los datos
plot(clima)
scatterplotMatrix(clima)
#PCA con media = 0 y desviacion estandar = 1
PCAclima<- prcomp(clima[2:8], center = T, scale. = T)
summary(PCAclima)
#Grafica de varianza de cada PC
apply(clima[2:8],2,sd)
screeplot(PCAclima)
summary(PCAclima)
#Grafica de varianza de cada PC
apply(clima[2:8],2,sd)
#Desviación estándar de componentes principales
PCAclima$sdev
#valores de PC
PCAclima$rotation
#Nuevos valores para los individuos según del PCA
PCAclima$x
#grafica de varianza de cada PC
screeplot(PCAclima, type="lines")
##loadings
apply(datos_clima[2:8],2,sd)
#valores de PC
PCAclima$rotation
clima
#grafica PCA (loadings)
biplot(PCAclima, scale=0)
#Correlación de índice (clima) con la riqueza de especies de aves
#Extraer datos del primer componente del PCA
PCAclima2<-as.data.frame(PCAclima$x)
#Correlación de índice (clima) con la riqueza de especies de aves
#Extraer datos del primer componente del PCA
PCAclima2<-as.data.frame(PCAclima$x)
PCAclima2[,1]
hist(PCAclima2[,1], xlab= "Indice climatico", ylab="Frecuencia", main="Histograma del indice climatico")
shapiro.test(PCAclima2[,1])
#Base de datos para aves
aves<-read.csv("BirdDiversity.csv", header=T)
str(aves)
summary(aves)
#Checando normalidad de datos para las aves
hist(aves$x, xlab= "Riqueza de spp de aves", ylab="Frecuencia", main="Histograma del riqueza de aves")
shapiro.test(aves$x)
#Correlación entre índice y diversidad
cor.test(PCAclima2[,1],aves$x)
plot(PCAclima2[,1],aves$x, xlab="Índice climático", ylab="Riqueza de spp de aves", main="Correlacion de indice con riqueza de aves")
#Correlación entre índice y diversidad
cor.test(PCAclima2[,1],aves$x)
hist(PCAclima2[,1], xlab= "Indice climatico", ylab="Frecuencia", main="Histograma del indice climatico")
shapiro.test(PCAclima2[,1])
#Checando normalidad de datos para las aves
hist(aves$x, xlab= "Riqueza de spp de aves", ylab="Frecuencia", main="Histograma del riqueza de aves")
shapiro.test(aves$x)
#Correlación entre índice y diversidad
cor.test(PCAclima2[,1],aves$x)
###Correlación entre riqueza y sitios
PCAclima3<-as.vector(PCAclima2[,1])
avesPC1<-cbind(aves, PCAclima3)
str(avesPC1)
#Especies de aves por sitio
aves$X<-as.numeric(aves$X)
str(avesPC1)
plot(aves, xlab="Sitio (distancias)", ylab="Riqueza de spp de aves", main="Riqueza de spp de aves por sitio")
m0<-lm(x ~ X, data = aves)
plot(m0)
hist(residuals(m1))
shapiro.test(residuals(m0))
summary(m0)
abline(m0$coefficients[1], m0$coefficients[2], lwd=1, col="red")
plot(aves, xlab="Sitio (distancias)", ylab="Riqueza de spp de aves", main="Riqueza de spp de aves por sitio")
abline(m0$coefficients[1], m0$coefficients[2], lwd=1, col="red")
#Sitios a distancia (de factor a numérico)
avesPC1$X<-as.numeric(avesPC1$X)
str(avesPC1)
#Clima (componente principal) según el sitio
plot(avesPC1$X, avesPC1$PCAclima3, xlab="Sitio", ylab="Condicion climatica (CP)", main="Parecido climatico entre sitios")
abline(m1$coefficients[1], m1$coefficients[2], lwd=1, col="red")
plot(m1)
hist(residuals(m1))
shapiro.test(residuals(m1))
summary(m1)
plot(avesPC1$X, avesPC1$PCAclima3, xlab="Sitio", ylab="Condicion climatica (CP)", main="Parecido climatico entre sitios")
#Clima (componente principal) según el sitio
m1<-lm(PCAclima3 ~ X, data = avesPC1)
plot(m1)
hist(residuals(m1))
shapiro.test(residuals(m1))
cor.test(abs(m1$residuals), m1$fitted.values)
summary(m1)
plot(avesPC1$X, avesPC1$PCAclima3, xlab="Sitio", ylab="Condicion climatica (CP)", main="Parecido climatico entre sitios")
abline(m1$coefficients[1], m1$coefficients[2], lwd=1, col="red")
str(avesPC1)
#Se prueba supuesto de homocedasticidad
#Ho:varianzas iguales
#Ha:varianzas no son iguales
bartlett.test(avesPC1$PCAclima3~avesPC1$X)
#Sitios a distancia (de factor a numérico)
avesPC1$X<-as.numeric(avesPC1$X)
str(avesPC1)
#Clima (componente principal) según el sitio
m1<-lm(PCAclima3 ~ X, data = avesPC1)
plot(m1)
#Se prueba supuesto de homocedasticidad
#Ho:varianzas iguales
#Ha:varianzas no son iguales
bartlett.test(avesPC1$PCAclima3 ~ avesPC1$X)
plot(m1$residuals~m1fitted.values)
cor.test(abs(m1$residuals), log(m1$fitted.values))
#Clima (componente principal) según el sitio
m1<-lm(PCAclima3 ~ X, data = avesPC1)
#Independencia de los residuales
#HO: Los residuales no están correlacionados con el valor ajustado
#HA: Los residuales están correlacionados con el valor ajustado
plot(m1$residuals~m1fitted.values)
cor.test(abs(m1$residuals), log(m1$fitted.values))
#######Pregunta 2: Diversidad de aves########
#Cargando los datos
clima<-read.csv("Climate.csv", header=T)
str(clima)
summary(clima)
#Revisando gráficas de los datos
plot(clima)
scatterplotMatrix(clima)
#PCA con media = 0 y desviacion estandar = 1
PCAclima<- prcomp(clima[2:8], center = T, scale. = T)
summary(PCAclima)
#Grafica de varianza de cada PC
apply(clima[2:8],2,sd)
screeplot(PCAclima)
#El PC1, agrupa la mayor proporcion de la varianza (0.61)
#Desviación estándar de componentes principales
PCAclima$sdev
#valores de PC (loadings)
PCAclima$rotation
#Nuevos valores para los individuos según del PCA
PCAclima$x
#grafica PCA (loadings)
biplot(PCAclima, scale=0)
#Correlación de índice (clima) con la riqueza de especies de aves
#Extraer datos del primer componente del PCA
PCAclima2<-as.data.frame(PCAclima$x)
PCAclima2[,1]
hist(PCAclima2[,1], xlab= "Indice climatico", ylab="Frecuencia", main="Histograma del indice climatico")
shapiro.test(PCAclima2[,1])
#Base de datos para aves
aves<-read.csv("BirdDiversity.csv", header=T)
str(aves)
summary(aves)
#Checando normalidad de datos para las aves
hist(aves$x, xlab= "Riqueza de spp de aves", ylab="Frecuencia", main="Histograma del riqueza de aves")
shapiro.test(aves$x)
#Los datos sí son normales
#Correlación entre índice y diversidad
cor.test(PCAclima2[,1],aves$x)
plot(PCAclima2[,1],aves$x, xlab="Índice climático", ylab="Riqueza de spp de aves", main="Correlacion de indice con riqueza de aves")
###Correlación entre riqueza y sitios
PCAclima3<-as.vector(PCAclima2[,1])
avesPC1<-cbind(aves, PCAclima3)
str(avesPC1)
#Sitios a distancia (de factor a numérico)
avesPC1$X<-as.numeric(avesPC1$X)
str(avesPC1)
#Clima (componente principal) según el sitio
m1<-lm(PCAclima3 ~ X, data = avesPC1)
plot(m1)
shapiro.test(residuals(m1))
cor.test(abs(m1$residuals), m1$fitted.values)
#Independencia de los residuales
#HO: Los residuales no están correlacionados con el valor ajustado
#HA: Los residuales están correlacionados con el valor ajustado
plot(m1$residuals~m1fitted.values)
shapiro.test(residuals(m1))
summary(m1)
viewport(summary(m1))
View(summary(m1))
plot(avesPC1$X, avesPC1$PCAclima3, xlab="Sitio", ylab="Condicion climatica (CP)", main="Parecido climatico entre sitios")
abline(m1$coefficients[1], m1$coefficients[2], lwd=1, col="red")
plot(avesPC1$X, avesPC1$PCAclima3, xlab="Sitio (distancia)", ylab="Condicion climatica (CP)", main="Parecido climatico entre sitios")
abline(m1$coefficients[1], m1$coefficients[2], lwd=1, col="red")
plot(avesPC1$X, avesPC1$PCAclima3, xlab="Sitio (distancia)", ylab="Condicion climatica (PC1)", main="Parecido climatico entre sitios")
abline(m1$coefficients[1], m1$coefficients[2], lwd=1, col="red")
#Condición climática con mayor diversidad
plot(avesPC1$PCAclima3, avesPC1$x, xlab="Condicion climatica (CP)", ylab="Riqueza de spp de aves", main="Parecido climatico entre sitios")
m2<-lm(x ~ PCAclima3, data = avesPC1)
plot(m2)
summary(m2)
#Condición climática con mayor diversidad
plot(avesPC1$PCAclima3, avesPC1$x, xlab="Condicion climatica (CP)", ylab="Riqueza de spp de aves", main="Parecido climatico entre sitios")
#Condición climática con mayor diversidad
plot(avesPC1$PCAclima3, avesPC1$x, xlab="Condicion climatica (PC1)", ylab="Riqueza de spp de aves", main="Parecido climatico entre sitios")
###U know where u have my document
setwd("//Doctorado")
##U install this shit
install.packages("ape")
install.packages("phangorn")
##U open this shit
library(ape)
library(phangorn)
##U did this magic thing
trees<-read.nexus("passer5023.nex")
str(trees)
trees$tree_8287
x = unique(dataframe!column)
?zip
setwd("~/passerdiet/passerdiet/Data/")
##Verificando arbol
paserdat= read.tsv("paserdat.tsv")
?read.csv
##Verificando arbol
paserdat= read.csv("paserdat.tsv", sep = ".\t")
#Creando datos para revbayes... En text edit buscar->buscar y remplazar -> comillas y borrar primera linea
paserdat<-data.frame(matched$dat$frugivoro)
##cargando datos
paserdat= read.csv("datosdoc.csv")
pasertree<-read.nexus("passertree.nex")
str(paserdat)
##Uniendo nombres de arbol y datos
setdiff(paserdat$Name, pasertree$tip.label)
##Verificando arbol
pasertree<-read.nexus("ConsenseTreeP.nex")
setdiff(paserdat$Name, pasertree$tip.label)
setdiff(pasertree$tip.label, paserdat$Name)
matched<-make.treedata(pasertree, paserdat, name_column = "Name")
write.nexus(matched$phy, file="pasertree.nex")
#Creando datos para revbayes... En text edit buscar->buscar y remplazar -> comillas y borrar primera linea
paserdat<-data.frame(matched$dat$frugivoro)
row.names(paserdat)<-matched$phy$tip.label
head(paserdat)
##Verificando arbol
pasertree<-read.nexus("ConsenseTreeP.nex")
setdiff(passertree$tip.label, paserdat$Name)
setdiff(pasertree$tip.label, paserdat$Name)
setdiff(paserdat$Name,pasertree$tip.label)
write.table(paserdat, file="paserdat.tsv", sep="\t")
write.table(pasercar, file="pasercar.tsv", sep="\t")
write.table(paserdat, file="paserdat.tsv", sep="\t")
#Creando datos para revbayes... En text edit buscar->buscar y remplazar -> comillas y borrar primera linea
paserdat<-data.frame(matched$dat$frugivoro)
setdiff(paserdat$Name, pasertree$tip.label)
setdiff(pasertree$tip.label, paserdat$Name)
matched<-make.treedata(pasertree, paserdat, name_column = "Name")
write.nexus(matched$phy, file="pasertree.nex")
##cargando datos
paserdat= read.csv("datosdoc.csv")
##Verificando arbol
pasertree<-read.nexus("ConsenseTreeP.nex")
##Uniendo nombres de arbol y datos
setdiff(paserdat$Name, pasertree$tip.label)
setdiff(pasertree$tip.label, paserdat$Name)
matched<-make.treedata(pasertree, paserdat, name_column = "Name")
library(ape)
library(treeplyr)
matched<-make.treedata(pasertree, paserdat, name_column = "Name")
write.nexus(matched$phy, file="pasertree.nex")
#Creando datos para revbayes... En text edit buscar->buscar y remplazar -> comillas y borrar primera linea
paserdat<-data.frame(matched$dat$frugivoro)
row.names(paserdat)<-matched$phy$tip.label
head(paserdat)
write.table(paserdat, file="paserdat.tsv", sep="\t")
##cargando datos
paserdat= read.csv("datosdoc.csv")
paserdat= na.omit("datosdoc.csv")
##Verificando arbol
pasertree<-read.nexus("ConsenseTreeP.nex")
##cargando datos
paserdat= read.csv("datosdoc.csv")
str(paserdat)
summary(paserdat)
##Verificando arbol
pasertree<-read.nexus("ConsenseTreeP.nex")
setdiff(paserdat$Name,pasertree$tip.label)
##Uniendo nombres de arbol y datos
setdiff(paserdat$Name, pasertree$tip.label)
setdiff(pasertree$tip.label, paserdat$Name)
matched<-make.treedata(pasertree, paserdat, name_column = "Name")
write.nexus(matched$phy, file="pasertree.nex")
#Creando datos para revbayes... En text edit buscar->buscar y remplazar -> comillas y borrar primera linea
paserdat<-data.frame(matched$dat$frugivoro)
row.names(paserdat)<-matched$phy$tip.label
head(paserdat)
write.table(paserdat, file="paserdat.tsv", sep="\t")
####Ahora para carotenoides
pasercar<-data.frame(matched$dat$carotenoide)
row.names(pasercar)<-matched$phy$tip.label
head(pasercar)
str(pasercar)
write.table(pasercar, file="pasercar.tsv", sep="\t")
?hisse
